const std = @import("std");
const flare = @import("flare");
const testing = std.testing;

pub const LoadError = error{
    InvalidConfig,
    ConfigPathUnavailable,
    ConfigAlreadyExists,
    OutOfMemory,
};

pub const LoadOptions = struct {
    path_override: ?[]const u8 = null,
};

pub const ShellConfig = struct {
    allocator: std.mem.Allocator,
    prompt: []const u8,
    interactive: bool,
    use_starship: bool,
    theme: ?[]const u8,
    history_file: ?[]const u8,
    editor: ?[]const u8,
    plugins: std.ArrayListUnmanaged([]const u8),

    pub fn initDefaults(allocator: std.mem.Allocator) !ShellConfig {
        var config = ShellConfig{
            .allocator = allocator,
            .prompt = try allocator.dupe(u8, default_prompt),
            .interactive = true,
            .use_starship = false, // Off by default, user can enable
            .theme = try allocator.dupe(u8, default_theme),
            .history_file = try allocator.dupe(u8, default_history_file),
            .editor = try allocator.dupe(u8, default_editor),
            .plugins = .{},
        };
        errdefer config.deinit();

        for (default_plugins) |plugin| {
            const owned = try allocator.dupe(u8, plugin);
            try config.plugins.append(allocator, owned);
        }

        return config;
    }

    pub fn deinit(self: *ShellConfig) void {
        self.allocator.free(self.prompt);
        if (self.theme) |value| self.allocator.free(value);
        if (self.history_file) |value| self.allocator.free(value);
        if (self.editor) |value| self.allocator.free(value);
        for (self.plugins.items) |plugin| self.allocator.free(plugin);
        self.plugins.deinit(self.allocator);
    }

    fn setPromptOwned(self: *ShellConfig, value: []const u8) void {
        self.allocator.free(self.prompt);
        self.prompt = value;
    }

    fn setOptionalStringOwned(self: *ShellConfig, field: *?[]const u8, value: []const u8) void {
        if (field.*) |prev| self.allocator.free(prev);
        field.* = value;
    }

    fn clearPlugins(self: *ShellConfig) void {
        for (self.plugins.items) |plugin| self.allocator.free(plugin);
        self.plugins.deinit(self.allocator);
        self.plugins = .{};
    }

    fn replacePlugins(self: *ShellConfig, list: std.ArrayListUnmanaged([]const u8)) void {
        self.plugins = list;
    }
};

const default_prompt = "ü™ê ${user}@${host} ${cwd} ‚Ä∫ ";
const default_theme = "powerlevel10k:lean";
const default_history_file = "${HOME}/.local/share/gshell/history";
const default_editor = "nvim";
const default_plugins = [_][]const u8{"git"};

const default_config_template =
    \\# ~/.gshrc ‚Äî generated by `gshell init`
    \\# Format: TOML (parsed by Flare)
    \\# Variables: ${user}, ${host}, ${cwd}, ${git}, ${exit_status}
    \\# Tip: Override any key via env vars like GSHELL__PROMPT="..."
    \\
    \\prompt = "ü™ê ${user}@${host} ${cwd} ‚Ä∫ "
    \\interactive = true
    \\
    \\# Enable Starship prompt (requires 'starship' binary installed)
    \\# Get it from: https://starship.rs
    \\use_starship = false
    \\
    \\theme = "powerlevel10k:lean"
    \\plugins = ["git"]
    \\history_file = "${HOME}/.local/share/gshell/history"
    \\editor = "nvim"
    \\
    \\# Uncomment to explore extra plugin locations
    \\# plugin_paths = ["${XDG_CONFIG_HOME}/gshell/plugins"]
    \\
;

const env_prefix = "GSHELL";
const env_separator = "__";

const ResolvedPath = struct {
    path: ?[]const u8,
    owned: bool,
};

pub fn load(allocator: std.mem.Allocator, options: LoadOptions) !ShellConfig {
    var shell_config = try ShellConfig.initDefaults(allocator);

    const path_info = try resolveConfigPath(allocator, options);
    defer {
        if (path_info.owned) {
            if (path_info.path) |p| allocator.free(p);
        }
    }

    if (path_info.path == null) {
        return shell_config;
    }

    const path = path_info.path.?;
    const flare_options = flare.LoadOptions{
        .files = &.{.{ .path = path, .required = false, .format = .toml }},
        .env = .{ .prefix = env_prefix, .separator = env_separator },
    };

    var flare_config = flare.load(allocator, flare_options) catch |err| {
        shell_config.deinit();
        return switch (err) {
            flare.FlareError.OutOfMemory => error.OutOfMemory,
            else => LoadError.InvalidConfig,
        };
    };
    defer flare_config.deinit();

    applyFlareConfig(&shell_config, &flare_config) catch |err| {
        shell_config.deinit();
        return err;
    };

    return shell_config;
}

fn applyFlareConfig(shell_config: *ShellConfig, source: *flare.Config) LoadError!void {
    const allocator = shell_config.allocator;

    if (source.hasKey("prompt")) {
        const prompt_value = source.getString("prompt", null) catch |err| switch (err) {
            flare.FlareError.OutOfMemory => return error.OutOfMemory,
            else => return LoadError.InvalidConfig,
        };
        const owned_prompt = try allocator.dupe(u8, prompt_value);
        shell_config.setPromptOwned(owned_prompt);
    }

    if (source.hasKey("interactive")) {
        const interactive_value = source.getBool("interactive", null) catch |err| switch (err) {
            flare.FlareError.OutOfMemory => return error.OutOfMemory,
            else => return LoadError.InvalidConfig,
        };
        shell_config.interactive = interactive_value;
    }

    if (source.hasKey("use_starship")) {
        const starship_value = source.getBool("use_starship", null) catch |err| switch (err) {
            flare.FlareError.OutOfMemory => return error.OutOfMemory,
            else => return LoadError.InvalidConfig,
        };
        shell_config.use_starship = starship_value;
    }

    if (source.hasKey("theme")) {
        const theme_value = source.getString("theme", null) catch |err| switch (err) {
            flare.FlareError.OutOfMemory => return error.OutOfMemory,
            else => return LoadError.InvalidConfig,
        };
        const owned_theme = try allocator.dupe(u8, theme_value);
        shell_config.setOptionalStringOwned(&shell_config.theme, owned_theme);
    }

    if (source.hasKey("history_file")) {
        const history_value = source.getString("history_file", null) catch |err| switch (err) {
            flare.FlareError.OutOfMemory => return error.OutOfMemory,
            else => return LoadError.InvalidConfig,
        };
        const owned_history = try allocator.dupe(u8, history_value);
        shell_config.setOptionalStringOwned(&shell_config.history_file, owned_history);
    }

    if (source.hasKey("editor")) {
        const editor_value = source.getString("editor", null) catch |err| switch (err) {
            flare.FlareError.OutOfMemory => return error.OutOfMemory,
            else => return LoadError.InvalidConfig,
        };
        const owned_editor = try allocator.dupe(u8, editor_value);
        shell_config.setOptionalStringOwned(&shell_config.editor, owned_editor);
    }

    if (source.hasKey("plugins")) {
        const plugin_values = source.getStringList("plugins") catch |err| switch (err) {
            flare.FlareError.OutOfMemory => return error.OutOfMemory,
            else => return LoadError.InvalidConfig,
        };

        var new_plugins = std.ArrayListUnmanaged([]const u8){};
        errdefer {
            for (new_plugins.items) |item| allocator.free(item);
            new_plugins.deinit(allocator);
        }

        for (plugin_values) |plugin| {
            const owned = try allocator.dupe(u8, plugin);
            try new_plugins.append(allocator, owned);
        }

        shell_config.clearPlugins();
        shell_config.replacePlugins(new_plugins);
    }
}

fn resolveConfigPath(allocator: std.mem.Allocator, options: LoadOptions) !ResolvedPath {
    if (options.path_override) |override| {
        return ResolvedPath{
            .path = try allocator.dupe(u8, override),
            .owned = true,
        };
    }

    const env_path = std.process.getEnvVarOwned(allocator, "GSHELL_CONFIG") catch |err| switch (err) {
        error.EnvironmentVariableNotFound => null,
        else => return err,
    };
    if (env_path) |value| {
        return ResolvedPath{ .path = value, .owned = true };
    }

    const home = std.process.getEnvVarOwned(allocator, "HOME") catch |err| switch (err) {
        error.EnvironmentVariableNotFound => return ResolvedPath{ .path = null, .owned = false },
        else => return err,
    };
    defer allocator.free(home);

    const joined = try std.fs.path.join(allocator, &[_][]const u8{ home, ".gshrc" });
    return ResolvedPath{ .path = joined, .owned = true };
}

pub fn ensureConfigPath(allocator: std.mem.Allocator, options: LoadOptions) ![]const u8 {
    const info = try resolveConfigPath(allocator, options);
    if (info.path == null) return LoadError.ConfigPathUnavailable;

    if (info.owned) {
        return info.path.?;
    }

    return allocator.dupe(u8, info.path.?);
}

pub fn writeDefaultConfig(allocator: std.mem.Allocator, options: LoadOptions, force: bool) ![]const u8 {
    const info = try resolveConfigPath(allocator, options);
    if (info.path == null) return LoadError.ConfigPathUnavailable;

    var path_slice = info.path.?;
    var owned = info.owned;
    if (!owned) {
        path_slice = try allocator.dupe(u8, path_slice);
        owned = true;
    }
    errdefer if (owned) allocator.free(path_slice);

    const flags = std.fs.File.CreateFlags{
        .read = true,
        .truncate = true,
        .exclusive = !force,
    };

    var file = std.fs.cwd().createFile(path_slice, flags) catch |err| switch (err) {
        error.PathAlreadyExists => return LoadError.ConfigAlreadyExists,
        else => return err,
    };
    defer file.close();

    try file.writeAll(default_config_template);

    return path_slice;
}

fn makeTmpPath(allocator: std.mem.Allocator, tmp: *testing.TmpDir, filename: []const u8) ![]const u8 {
    const base = try tmp.dir.realpathAlloc(allocator, ".");
    defer allocator.free(base);
    return std.fs.path.join(allocator, &[_][]const u8{ base, filename });
}

fn readFileAlloc(allocator: std.mem.Allocator, path: []const u8) ![]u8 {
    var file = try std.fs.cwd().openFile(path, .{ .mode = .read_only });
    defer file.close();
    return try file.readToEndAlloc(allocator, 1 << 20);
}

fn writeFile(path: []const u8, contents: []const u8) !void {
    var file = try std.fs.cwd().createFile(path, .{ .truncate = true });
    defer file.close();
    try file.writeAll(contents);
}

fn setEnvVar(allocator: std.mem.Allocator, key: []const u8, value: []const u8) !void {
    const key_z = try std.fmt.allocPrintZ(allocator, "{s}", .{key});
    defer allocator.free(key_z);
    const value_z = try std.fmt.allocPrintZ(allocator, "{s}", .{value});
    defer allocator.free(value_z);
    try std.posix.setenvZ(key_z.ptr, value_z.ptr, true);
}

fn unsetEnvVar(allocator: std.mem.Allocator, key: []const u8) !void {
    const key_z = try std.fmt.allocPrintZ(allocator, "{s}", .{key});
    defer allocator.free(key_z);
    try std.posix.unsetenvZ(key_z.ptr);
}

test "load default config when file missing" {
    const allocator = testing.allocator;
    var tmp = testing.tmpDir(.{});
    defer tmp.cleanup();

    const path = try makeTmpPath(allocator, &tmp, "missing.gshrc");
    defer allocator.free(path);

    var cfg = try load(allocator, .{ .path_override = path });
    defer cfg.deinit();

    try testing.expectEqualStrings(default_prompt, cfg.prompt);
    try testing.expect(cfg.interactive);
    try testing.expect(cfg.theme != null);
    try testing.expectEqualStrings(default_theme, cfg.theme.?);
    try testing.expect(cfg.history_file != null);
    try testing.expectEqualStrings(default_history_file, cfg.history_file.?);
    try testing.expect(cfg.editor != null);
    try testing.expectEqualStrings(default_editor, cfg.editor.?);
    try testing.expectEqual(@as(usize, default_plugins.len), cfg.plugins.items.len);
    for (cfg.plugins.items, default_plugins) |actual, expected| {
        try testing.expectEqualStrings(expected, actual);
    }
}

test "load config values" {
    const allocator = testing.allocator;
    var tmp = testing.tmpDir(.{});
    defer tmp.cleanup();

    const path = try makeTmpPath(allocator, &tmp, "configured.gshrc");
    defer allocator.free(path);

    try writeFile(path,
        \\prompt = "zsh> "
        \\interactive = false
        \\plugins = ["git", "docker"]
        \\theme = "lean"
        \\history_file = "/tmp/gshell_hist"
        \\editor = "nano"
    );

    var cfg = try load(allocator, .{ .path_override = path });
    defer cfg.deinit();

    try testing.expectEqualStrings("zsh> ", cfg.prompt);
    try testing.expect(!cfg.interactive);
    try testing.expectEqual(@as(usize, 2), cfg.plugins.items.len);
    try testing.expectEqualStrings("git", cfg.plugins.items[0]);
    try testing.expectEqualStrings("docker", cfg.plugins.items[1]);
    try testing.expect(cfg.theme != null);
    try testing.expectEqualStrings("lean", cfg.theme.?);
    try testing.expect(cfg.history_file != null);
    try testing.expectEqualStrings("/tmp/gshell_hist", cfg.history_file.?);
    try testing.expect(cfg.editor != null);
    try testing.expectEqualStrings("nano", cfg.editor.?);
}

test "invalid config returns error" {
    const allocator = testing.allocator;
    var tmp = testing.tmpDir(.{});
    defer tmp.cleanup();

    const path = try makeTmpPath(allocator, &tmp, "invalid.gshrc");
    defer allocator.free(path);

    try writeFile(path,
        \\prompt = "unterminated
    );

    try testing.expectError(LoadError.InvalidConfig, load(allocator, .{ .path_override = path }));
}

test "env overrides prompt" {
    const allocator = testing.allocator;
    var tmp = testing.tmpDir(.{});
    defer tmp.cleanup();

    const path = try makeTmpPath(allocator, &tmp, "env.gshrc");
    defer allocator.free(path);

    const env_key = "GSHELL__PROMPT";
    const env_prompt = "üåà env prompt ‚ú® ";

    const previous = std.process.getEnvVarOwned(allocator, env_key) catch |err| switch (err) {
        error.EnvironmentVariableNotFound => null,
        else => return err,
    };
    defer {
        if (previous) |value| {
            setEnvVar(allocator, env_key, value) catch {};
            allocator.free(value);
        } else {
            unsetEnvVar(allocator, env_key) catch {};
        }
    }

    try setEnvVar(allocator, env_key, env_prompt);

    var cfg = try load(allocator, .{ .path_override = path });
    defer cfg.deinit();

    try testing.expectEqualStrings(env_prompt, cfg.prompt);
}

test "load config handles unicode prompt" {
    const allocator = testing.allocator;
    var tmp = testing.tmpDir(.{});
    defer tmp.cleanup();

    const path = try makeTmpPath(allocator, &tmp, "unicode.gshrc");
    defer allocator.free(path);

    const unicode_prompt = "‚ú® œà ${user} ‚ùØ ";
    try writeFile(path,
        \\prompt = "‚ú® œà ${user} ‚ùØ "
        \\interactive = true
    );

    var cfg = try load(allocator, .{ .path_override = path });
    defer cfg.deinit();

    try testing.expectEqualStrings(unicode_prompt, cfg.prompt);
}

test "writeDefaultConfig respects force" {
    const allocator = testing.allocator;
    var tmp = testing.tmpDir(.{});
    defer tmp.cleanup();

    const path = try makeTmpPath(allocator, &tmp, "default.gshrc");
    defer allocator.free(path);

    const actual_path = try writeDefaultConfig(allocator, .{ .path_override = path }, false);
    defer allocator.free(actual_path);
    try testing.expectEqualStrings(path, actual_path);

    const contents = try readFileAlloc(allocator, path);
    defer allocator.free(contents);
    try testing.expectEqualStrings(default_config_template, contents);

    try testing.expectError(LoadError.ConfigAlreadyExists, writeDefaultConfig(allocator, .{ .path_override = path }, false));

    const forced_path = try writeDefaultConfig(allocator, .{ .path_override = path }, true);
    defer allocator.free(forced_path);
    try testing.expectEqualStrings(path, forced_path);
}

test "default config template matches asset" {
    const allocator = testing.allocator;
    const asset_contents = try readFileAlloc(allocator, "assets/templates/default.gshrc");
    defer allocator.free(asset_contents);

    try testing.expectEqualStrings(default_config_template, asset_contents);
    try testing.expect(std.mem.indexOf(u8, default_config_template, default_prompt) != null);
}
